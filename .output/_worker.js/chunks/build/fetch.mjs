import{z as e}from"../nitro/nitro.mjs";import{E as a,J as t,v as r,K as s,L as n}from"./server.mjs";function useRequestFetch(){var e;return(null==(e=function(e){var t;return e||(e=a()),null==(t=e.ssrContext)?void 0:t.event}())?void 0:e.$fetch)||globalThis.$fetch}function useAsyncData(...e){var n;const o="string"==typeof e[e.length-1]?e.pop():void 0;"string"!=typeof e[0]&&e.unshift(o);let[i,u,l={}]=e;if("string"!=typeof i)throw new TypeError("[nuxt] [asyncData] key must be a string.");if("function"!=typeof u)throw new TypeError("[nuxt] [asyncData] handler must be a function.");const c=a(),d=u;l.server??(l.server=!0),l.default??(l.default=()=>t.value),l.getCachedData??(l.getCachedData=()=>c.isHydrating?c.payload.data[i]:c.static.data[i]),l.lazy??(l.lazy=!1),l.immediate??(l.immediate=!0),l.deep??(l.deep=t.deep),l.dedupe??(l.dedupe="cancel");const f=l.getCachedData(i,c),y=null!=f;if(!c._asyncData[i]||!l.immediate){(n=c.payload._errors)[i]??(n[i]=t.errorValue);const e=l.deep?r.ref:r.shallowRef;c._asyncData[i]={data:e(y?f:l.default()),pending:r.ref(!y),error:r.toRef(c.payload._errors,i),status:r.ref("idle"),_default:l.default}}const p={...c._asyncData[i]};delete p._default,p.refresh=p.execute=(e={})=>{if(c._asyncDataPromises[i]){if("defer"===(a=e.dedupe??l.dedupe)||!1===a)return c._asyncDataPromises[i];c._asyncDataPromises[i].cancelled=!0}var a;if(e._initial||c.isHydrating&&!1!==e._initial){const a=e._initial?f:l.getCachedData(i,c);if(null!=a)return Promise.resolve(a)}p.pending.value=!0,p.status.value="pending";const n=new Promise(((e,a)=>{try{e(d(c))}catch(e){a(e)}})).then((async e=>{if(n.cancelled)return c._asyncDataPromises[i];let a=e;l.transform&&(a=await l.transform(e)),l.pick&&(a=function(e,a){const t={};for(const r of a)t[r]=e[r];return t}(a,l.pick)),c.payload.data[i]=a,p.data.value=a,p.error.value=t.errorValue,p.status.value="success"})).catch((e=>{if(n.cancelled)return c._asyncDataPromises[i];p.error.value=s(e),p.data.value=r.unref(l.default()),p.status.value="error"})).finally((()=>{n.cancelled||(p.pending.value=!1,delete c._asyncDataPromises[i])}));return c._asyncDataPromises[i]=n,c._asyncDataPromises[i]},p.clear=()=>function(e,a){a in e.payload.data&&(e.payload.data[a]=void 0);a in e.payload._errors&&(e.payload._errors[a]=t.errorValue);e._asyncData[a]&&(e._asyncData[a].data.value=void 0,e._asyncData[a].error.value=t.errorValue,e._asyncData[a].pending.value=!1,e._asyncData[a].status.value="idle");a in e._asyncDataPromises&&(e._asyncDataPromises[a]&&(e._asyncDataPromises[a].cancelled=!0),e._asyncDataPromises[a]=void 0)}(c,i);if(!1!==l.server&&c.payload.serverRendered&&l.immediate){const e=p.refresh({_initial:!0});r.getCurrentInstance()?r.onServerPrefetch((()=>e)):c.hook("app:created",(async()=>{await e}))}const m=Promise.resolve(c._asyncDataPromises[i]).then((()=>p));return Object.assign(m,p),m}function useFetch(a,t,s){const[o={},i]="string"==typeof t?[{},t]:[t,s],u=r.computed((()=>r.toValue(a))),l=o.key||e([i,"string"==typeof u.value?u.value:"",...generateOptionSegments(o)]);if(!l||"string"!=typeof l)throw new TypeError("[nuxt] [useFetch] key must be a string: "+l);if(!a)throw new Error("[nuxt] [useFetch] request is missing.");const c=l===i?"$f"+l:l;if(!o.baseURL&&"string"==typeof u.value&&"/"===u.value[0]&&"/"===u.value[1])throw new Error('[nuxt] [useFetch] the request URL must not start with "//".');const{server:d,lazy:f,default:y,transform:p,pick:m,watch:v,immediate:h,getCachedData:g,deep:D,dedupe:_,...b}=o,w=r.reactive({...n,...b,cache:"boolean"==typeof o.cache?void 0:o.cache});let P;return useAsyncData(c,(()=>{var e;null==(e=null==P?void 0:P.abort)||e.call(P,new DOMException("Request aborted as another request to the same endpoint was initiated.","AbortError")),P="undefined"!=typeof AbortController?new AbortController:{};const a=r.toValue(o.timeout);let t;a&&(t=setTimeout((()=>P.abort(new DOMException("Request aborted due to timeout.","AbortError"))),a),P.signal.onabort=()=>clearTimeout(t));let s=o.$fetch||globalThis.$fetch;if(!o.$fetch){"string"==typeof u.value&&"/"===u.value[0]&&(!r.toValue(o.baseURL)||"/"===r.toValue(o.baseURL)[0])&&(s=useRequestFetch())}return s(u.value,{signal:P.signal,...w}).finally((()=>{clearTimeout(t)}))}),{server:d,lazy:f,default:y,transform:p,pick:m,immediate:h,getCachedData:g,deep:D,dedupe:_,watch:!1===v?[]:[w,u,...v||[]]})}function generateOptionSegments(e){var a;const t=[(null==(a=r.toValue(e.method))?void 0:a.toUpperCase())||"GET",r.toValue(e.baseURL)];for(const a of[e.params||e.query]){const e=r.toValue(a);if(!e)continue;const s={};for(const[a,t]of Object.entries(e))s[r.toValue(a)]=r.toValue(t);t.push(s)}return t}export{useFetch as a,useAsyncData as u};
//# sourceMappingURL=fetch.mjs.map
